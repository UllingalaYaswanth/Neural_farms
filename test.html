<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cesium - Realistic Traffic System</title>
  <!-- CesiumJS -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Cesium.js"></script> 
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Widgets/widgets.css"  rel="stylesheet" />
  <style>
    html, body, #cesiumContainer {
      width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
    }
    .dashboard {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      font-family: sans-serif;
      padding: 10px 20px;
      border-radius: 8px;
      z-index: 1000;
      min-width: 250px;
      box-shadow: 0 0 10px black;
    }
    .dashboard h3 {
      margin-top: 0;
    }
    .dashboard ul {
      list-style-type: none;
      padding-left: 0;
      margin-bottom: 0;
    }
    .dashboard li {
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Dashboard Panel -->
  <div class="dashboard">
    <h3>Traffic Status</h3>
    <ul>
      <li><strong>Vehicles:</strong> <span id="vehicleCount">0</span></li>
      <li><strong>Green Lights:</strong> <span id="greenLights">0</span></li>
      <li><strong>Red Lights:</strong> <span id="redLights">0</span></li>
      <li><strong>Accidents:</strong> <span id="accidentCount">0</span></li>
    </ul>
    <h4>Accidents</h4>
    <ul id="accidentList">
      <li>No active accidents.</li>
    </ul>
  </div>

  <script>
    // Cesium ion token
    Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2YjhlMmVkNC1hYWVjLTQxYWEtOGZhYS1iOGQyNDUxY2ZlMTUiLCJpZCI6MjY0Nzg3LCJpYXQiOjE3MzUxMTAzMzV9.tdJk1ppDaw9AEy9bFB6RBU9T3H0-xOlIqVlrjDBJGQo";
    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldAnimate: true,
      timeline: true,
      animation: true
    });

    // Configuration
    const config = {
      maxVehicles: 10,
      vehicleSpawnRate: 1000,
      accidentProbability: 0.003,
      maxAccidents: 5
    };
    let vehicleCount = 0;
    let accidentCount = 0;
    let greenLightCount = 0;
    let redLightCount = 0;
    let activeAccidents = [];

    const countEls = {
      vehicle: document.getElementById('vehicleCount'),
      red: document.getElementById('redLights'),
      green: document.getElementById('greenLights'),
      accident: document.getElementById('accidentCount')
    };

    function updateDashboard() {
      countEls.vehicle.textContent = vehicleCount;
      countEls.red.textContent = redLightCount;
      countEls.green.textContent = greenLightCount;
      countEls.accident.textContent = accidentCount;

      const accidentListEl = document.getElementById('accidentList');
      if (!accidentListEl) return;
      accidentListEl.innerHTML = '';

      if (activeAccidents.length === 0) {
        accidentListEl.innerHTML = '<li>No active accidents.</li>';
        return;
      }

      activeAccidents.forEach((acc, index) => {
        const cartographic = Cesium.Cartographic.fromCartesian(acc.position);
        const lon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(5);
        const lat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(5);

        const li = document.createElement('li');
        li.innerText = `#${index + 1} â€” Lat: ${lat}, Lon: ${lon}`;
        accidentListEl.appendChild(li);
      });
    }

    function updateVehicleCount(change) {
      vehicleCount = Math.max(0, vehicleCount + change);
      updateDashboard();
    }

    function updateAccidentCount(change) {
      accidentCount = Math.max(0, accidentCount + change);
      updateDashboard();
    }

    function updateLightStatus(greenChange, redChange) {
      greenLightCount = Math.max(0, greenLightCount + greenChange);
      redLightCount = Math.max(0, redLightCount + redChange);
      updateDashboard();
    }

    async function loadTileset() {
      try {
        const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(3048665);
        viewer.scene.primitives.add(tileset);
        await viewer.zoomTo(tileset);
        const extras = tileset.asset.extras;
        if (extras?.ion?.defaultStyle) {
          tileset.style = new Cesium.Cesium3DTileStyle(extras.ion.defaultStyle);
        }
      } catch (error) {
        console.error("Error loading tileset:", error);
      }
    }

    function extractRoadPaths(geojson) {
      const mainRoads = [];
      const sideRoads = [];
      geojson.features.forEach(f => {
        if (!f.geometry) return;
        if (f.properties?.highway === 'primary' || f.properties?.highway === 'secondary') {
          if (f.geometry.type === "LineString") {
            mainRoads.push(f.geometry.coordinates);
          } else if (f.geometry.type === "MultiLineString") {
            mainRoads.push(...f.geometry.coordinates);
          }
        } else {
          if (f.geometry.type === "LineString") {
            sideRoads.push(f.geometry.coordinates);
          } else if (f.geometry.type === "MultiLineString") {
            sideRoads.push(...f.geometry.coordinates);
          }
        }
      });
      return { mainRoads, sideRoads };
    }

    function createPositionProperty(coordinates, startTime, speed) {
      const positionProperty = new Cesium.SampledPositionProperty();
      const positions = coordinates.map(coord =>
        Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 1)
      );
      let totalDistance = 0;
      const distances = [];
      for (let i = 1; i < positions.length; i++) {
        const dist = Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
        distances.push(dist);
        totalDistance += dist;
      }
      const totalTime = totalDistance / speed;
      let accumulatedTime = 0;
      positionProperty.addSample(startTime, positions[0]);
      for (let i = 1; i < positions.length; i++) {
        const segmentTime = (distances[i - 1] / totalDistance) * totalTime;
        accumulatedTime += segmentTime;
        const time = Cesium.JulianDate.addSeconds(startTime, accumulatedTime, new Cesium.JulianDate());
        positionProperty.addSample(time, positions[i]);
      }
      return { positionProperty, duration: totalTime };
    }

    function addTrafficLight(position) {
      const elevatedPosition = Cesium.Cartesian3.add(
        position,
        new Cesium.Cartesian3(0, 0, 5),
        new Cesium.Cartesian3()
      );

      const lightEntity = viewer.entities.add({
        position: elevatedPosition,
        model: {
          uri: 'http://192.168.6.225:8082/traffic-light.glb',
          scale: 0.5,
          minimumPixelSize: 16
        },
        label: {
          text: "RED",
          font: '14px sans-serif',
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          fillColor: Cesium.Color.RED,
          outlineWidth: 2,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -30),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });

      setupTrafficLight(lightEntity);
      return lightEntity;
    }

    function setupTrafficLight(lightEntity) {
      let isGreen = false;
      lightEntity.label.fillColor = Cesium.Color.RED;
      lightEntity.label.text = "RED";

      viewer.clock.onTick.addEventListener(() => {
        const now = Cesium.JulianDate.now();
        const secondsSinceChange = Cesium.JulianDate.secondsDifference(now, lightEntity.lastChange || now);
        const threshold = isGreen ? 30 : 20;

        if (secondsSinceChange > threshold || !lightEntity.lastChange) {
          isGreen = !isGreen;
          lightEntity.lastChange = now;
          lightEntity.label.fillColor = isGreen ? Cesium.Color.LIME : Cesium.Color.RED;
          lightEntity.label.text = isGreen ? "GREEN" : "RED";
          updateLightStatus(isGreen ? 1 : -1, isGreen ? -1 : 1);
        }
      });
    }

    function spawnVehicle(coordinates, vehicleType, startTime, isMainRoad) {
      if (vehicleCount >= config.maxVehicles) return;
      const speedWithVariation = vehicleType.speed * (0.9 + Math.random() * 0.2);
      const { positionProperty, duration } = createPositionProperty(coordinates, startTime, speedWithVariation);
      updateVehicleCount(1);
      const entity = viewer.entities.add({
        name: `${vehicleType.name} ${vehicleCount}`,
        position: positionProperty,
        model: {
          uri: vehicleType.uri,
          minimumPixelSize: 8,
          maximumScale: 20,
          scale: 0.6
        },
        orientation: new Cesium.VelocityOrientationProperty(positionProperty)
      });
      setTimeout(() => {
        viewer.entities.remove(entity);
        updateVehicleCount(-1);
      }, duration * 1000);
    }

    function setupContinuousSpawning(roadCoordinates) {
      setInterval(() => {
        if (vehicleCount >= config.maxVehicles) return;
        const useMainRoad = Math.random() < 0.7 && roadCoordinates.mainRoads.length > 0;
        const roads = useMainRoad ? roadCoordinates.mainRoads : roadCoordinates.sideRoads;
        if (roads.length === 0) return;
        const pathIndex = Math.floor(Math.random() * roads.length);
        const coordinates = roads[pathIndex];
        if (coordinates.length < 2) return;
        const vehicleTypes = [
          { name: "Truck", uri: "http://192.168.6.225:8082/ambulance.glb", speed: 3.33 }
        ];
        const vehicleType = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
        const startTime = Cesium.JulianDate.now();
        spawnVehicle(coordinates, vehicleType, startTime, useMainRoad);
      }, config.vehicleSpawnRate);
    }

    function placeLightsEvery400Meters(paths) {
      paths.forEach(path => {
        let positions = path.map(coord =>
          Cesium.Cartesian3.fromDegrees(coord[0], coord[1])
        );

        let accumulatedDistance = 0;
        let lightPositions = [];

        for (let i = 1; i < positions.length; i++) {
          const segmentLength = Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
          let remaining = accumulatedDistance;

          while (remaining + 400 <= accumulatedDistance + segmentLength) {
            const ratio = (400 - remaining) / segmentLength;
            const interpolated = Cesium.Cartesian3.multiplyByScalar(
              Cesium.Cartesian3.subtract(positions[i], positions[i - 1], new Cesium.Cartesian3()),
              ratio,
              new Cesium.Cartesian3()
            );
            const newPosition = Cesium.Cartesian3.add(positions[i - 1], interpolated, new Cesium.Cartesian3());
            lightPositions.push(newPosition);
            remaining += 400;
          }

          accumulatedDistance += segmentLength;
        }

        lightPositions.forEach(pos => {
          addTrafficLight(pos);
        });
      });
    }

    function createAccident(position) {
      const cartographic = Cesium.Cartographic.fromCartesian(position);

      const ellipse = viewer.entities.add({
        position: position,
        ellipse: {
          semiMinorAxis: 10,
          semiMajorAxis: 10,
          material: Cesium.Material.fromType('Color', {
            color: Cesium.Color.RED.withAlpha(0.5)
          })
        },
        label: {
          text: 'HAZARD',
          font: '16px sans-serif',
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          fillColor: Cesium.Color.RED,
          outlineColor: Cesium.Color.BLACK,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, 25)
        }
      });

      activeAccidents.push({ position, entity: ellipse });
      updateAccidentCount(1);

      setTimeout(() => {
        viewer.entities.remove(ellipse);
        const index = activeAccidents.findIndex(a => a.entity === ellipse);
        if (index !== -1) activeAccidents.splice(index, 1);
        updateAccidentCount(-1);
      }, 30000); // Remove after 30 seconds
    }

    function startRandomAccidents(roadCoordinates) {
      setInterval(() => {
        if (accidentCount >= config.maxAccidents) return;

        const allRoads = [...roadCoordinates.mainRoads, ...roadCoordinates.sideRoads];
        if (allRoads.length === 0) return;

        const path = allRoads[Math.floor(Math.random() * allRoads.length)];
        if (path.length < 2) return;

        const index = Math.floor(Math.random() * (path.length - 1));
        const coord = path[index];
        const position = Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 5);

        createAccident(position);
      }, 10000);
    }

    Promise.all([
      loadTileset(),
      fetch('http://192.168.6.225:8081/api/roads')
        .then(response => response.json())
        .then(geojson => {
          const roadCoordinates = extractRoadPaths(geojson);
          Cesium.GeoJsonDataSource.load(geojson, {
            stroke: Cesium.Color.YELLOW.withAlpha(0.5),
            strokeWidth: 2,
            clampToGround: true
          }).then(dataSource => {
            viewer.dataSources.add(dataSource);
          });

          function setupTrafficLightsAtIntersections(roadCoordinates) {
            const intersections = [];
            roadCoordinates.mainRoads.forEach(mainRoad => {
              roadCoordinates.sideRoads.forEach(sideRoad => {
                const startPoint = sideRoad[0];
                for (let i = 0; i < mainRoad.length; i++) {
                  const dx = startPoint[0] - mainRoad[i][0];
                  const dy = startPoint[1] - mainRoad[i][1];
                  if (Math.sqrt(dx * dx + dy * dy) < 0.0005) {
                    intersections.push(Cesium.Cartesian3.fromDegrees(mainRoad[i][0], mainRoad[i][1]));
                  }
                }
              });
            });
            intersections.slice(0, 5).forEach(pos => {
              addTrafficLight(pos);
            });
          }

          setupTrafficLightsAtIntersections(roadCoordinates);
          placeLightsEvery400Meters([...roadCoordinates.mainRoads, ...roadCoordinates.sideRoads]);
          setupContinuousSpawning(roadCoordinates);
          startRandomAccidents(roadCoordinates);

          if (roadCoordinates.mainRoads.length > 0) {
            const firstPath = roadCoordinates.mainRoads[0];
            const mid = Math.floor(firstPath.length / 2);
            viewer.camera.flyTo({
              destination: Cesium.Rectangle.fromDegrees(
                firstPath[mid][0] - 0.01,
                firstPath[mid][1] - 0.005,
                firstPath[mid][0] + 0.01,
                firstPath[mid][1] + 0.005
              )
            });
          }
        })
    ]).catch(err => {
      console.error("Failed to load one or more components:", err);
    });

    updateDashboard();
  </script>
</body>
</html>